<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>密码学的学习笔记 | 知政的个人博客</title>
<meta name=keywords content="密码学"><meta name=description content="密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密
信息安全（机密性，完整性，可用性，不可抵赖性）
Hash函数
hash可以用于校验文件是否完整，数字签名的摘要信息等等
hash函数是将任意大小的输入映射成固定大小的哈希值的函数
hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）
常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等
md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）
简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算
sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）
md5和sha1的计算过程：
先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的
也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间
确保这个消息的长度=输入消息+64+填充 = 512的整倍数
md5会初始化4个32bit的值，sha1会初始化5个32bit的值
md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算
每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值
计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值
如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果
mod 模计算
sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式
注意：md5和sha1都不安全了
md5
cryptographically broken and unsuitable for further use
users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use
sha1
谷歌SHA1碰撞实验
结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数
对称加密
AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14
计算过程：
AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）
128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵
加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵"><meta name=author content="Me"><link rel=canonical href=https://99999.fun/posts/165/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css rel="preload stylesheet" as=style><link rel=icon href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://99999.fun/favicon.ico><link rel=apple-touch-icon href=https://99999.fun/favicon.ico><link rel=mask-icon href=https://99999.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://99999.fun/posts/165/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="密码学的学习笔记"><meta property="og:description" content="密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密
信息安全（机密性，完整性，可用性，不可抵赖性）
Hash函数
hash可以用于校验文件是否完整，数字签名的摘要信息等等
hash函数是将任意大小的输入映射成固定大小的哈希值的函数
hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）
常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等
md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）
简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算
sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）
md5和sha1的计算过程：
先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的
也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间
确保这个消息的长度=输入消息+64+填充 = 512的整倍数
md5会初始化4个32bit的值，sha1会初始化5个32bit的值
md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算
每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值
计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值
如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果
mod 模计算
sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式
注意：md5和sha1都不安全了
md5
cryptographically broken and unsuitable for further use
users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use
sha1
谷歌SHA1碰撞实验
结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数
对称加密
AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14
计算过程：
AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）
128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵
加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵"><meta property="og:type" content="article"><meta property="og:url" content="https://99999.fun/posts/165/"><meta property="og:image" content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-01T10:49:25+08:00"><meta property="article:modified_time" content="2024-03-01T10:49:25+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="密码学的学习笔记"><meta name=twitter:description content="密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密
信息安全（机密性，完整性，可用性，不可抵赖性）
Hash函数
hash可以用于校验文件是否完整，数字签名的摘要信息等等
hash函数是将任意大小的输入映射成固定大小的哈希值的函数
hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）
常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等
md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）
简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算
sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）
md5和sha1的计算过程：
先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的
也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间
确保这个消息的长度=输入消息+64+填充 = 512的整倍数
md5会初始化4个32bit的值，sha1会初始化5个32bit的值
md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算
每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值
计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值
如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果
mod 模计算
sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式
注意：md5和sha1都不安全了
md5
cryptographically broken and unsuitable for further use
users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use
sha1
谷歌SHA1碰撞实验
结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数
对称加密
AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14
计算过程：
AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）
128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵
加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://99999.fun/posts/"},{"@type":"ListItem","position":2,"name":"密码学的学习笔记","item":"https://99999.fun/posts/165/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"密码学的学习笔记","name":"密码学的学习笔记","description":"密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密\n信息安全（机密性，完整性，可用性，不可抵赖性）\nHash函数\nhash可以用于校验文件是否完整，数字签名的摘要信息等等\nhash函数是将任意大小的输入映射成固定大小的哈希值的函数\nhash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）\n常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等\nmd5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）\n简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算\nsha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）\nmd5和sha1的计算过程：\n先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的\n也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间\n确保这个消息的长度=输入消息+64+填充 = 512的整倍数\nmd5会初始化4个32bit的值，sha1会初始化5个32bit的值\nmd5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算\n每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值\n计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值\n如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果\nmod 模计算\nsha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式\n注意：md5和sha1都不安全了\nmd5\ncryptographically broken and unsuitable for further use\nusers should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use\nsha1\n谷歌SHA1碰撞实验\n结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数\n对称加密\nAES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14\n计算过程：\nAES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）\n128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵\n加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵","keywords":["密码学"],"articleBody":"密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密\n信息安全（机密性，完整性，可用性，不可抵赖性）\nHash函数\nhash可以用于校验文件是否完整，数字签名的摘要信息等等\nhash函数是将任意大小的输入映射成固定大小的哈希值的函数\nhash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）\n常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等\nmd5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）\n简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算\nsha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）\nmd5和sha1的计算过程：\n先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的\n也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间\n确保这个消息的长度=输入消息+64+填充 = 512的整倍数\nmd5会初始化4个32bit的值，sha1会初始化5个32bit的值\nmd5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算\n每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值\n计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值\n如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果\nmod 模计算\nsha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式\n注意：md5和sha1都不安全了\nmd5\ncryptographically broken and unsuitable for further use\nusers should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use\nsha1\n谷歌SHA1碰撞实验\n结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数\n对称加密\nAES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14\n计算过程：\nAES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）\n128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵\n加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵\n先进行轮密钥加，每轮输入与轮密钥异或，得到的值，当解密的时候，只需要再异或该轮密钥即可得到输入，原理就是相同的两个数进行异或，结果为0，异或计算就是不带进位的二进制加法，1异或1，等于0，0异或1，等于1\n然后字节替换（subbytes），经过轮密钥加每个字节通过十六进制进行表示，十六进制的第一个数为行，第二个数字为列，通过s盒找到对应十六进制进行替换，这个s盒是16x16的正方形矩阵，还有逆s盒，用来解密\ns盒的16*16的十六进制是通过计算得到的，计算过程：\n先进行16*16初始化，然后对每个元素计算其乘法逆元\n以11为例（这个11是十六进制的），二进制为10001\n10001的多项式为f(x) = x的5次方+1\n意思为第1位和第五位为1\nAES使用了不可约多项式m(x)=x8+x4+x3+x+1\n行移位变换：就是将4*4的正方形矩阵的行都向左移动，例如第二行左移2位，第一行不变\n列混淆变换：将4*4的正方形矩阵的取一列乘以C(X)矩阵，得到一个新的值，放回原来的位置\n正方形矩阵的列和C(X)矩阵的行进行计算，就可以得到4*4的经过列混淆变换的新矩阵\n列混淆变换计算过程：\n假设取了A1，0B，BD，C1的一列数据\n即（02*A1）,(03*0B)，(01*AF)，(01*C1)\n通过十六进制转二进制，然后通过多项式表达式\n02为10，为x\nA1为10100001，为x的7次方+x的5次方+1\nx乘以（x的7次方+x的5次方+1）= x的八次方+x的六次方+x\n得到10100010，为A2\n以此类推，得到四个二进制的值。然后这四个二进制进行异或相加，得到的值就是该列的新值\n密钥扩展算法\n将密钥编排成4个32位的初始密钥，最后一个32位的密钥通过G函数得到的结果，与第一个32位的密钥进行异或计算得到下一轮的第一个32位的密钥，下一轮的第一个32位的密钥和初始密钥的第二个的32位初始密钥进行异或，得到下一轮的第二个32位的密钥，一直计算到第11轮（轮密钥加需要进行10次，算上第0轮，也就是第11轮，也就是需要进行44次异或处理（4x11））\n分组密码（分块加密，块密码）\n将明文分成多个等长的块，并且使用确定的加密算法和密钥对每一个分组的块分别加密或者解密\n工作模式，分组密码的解决方案（避免密钥长度，输入文长度，重放，完整度等问题及隐患）\n初始化向量（Initialization Vector）：随机初始化向量，生成一个随机的值，并且不会复用，确保其唯一性\n填充方式（Padding）：在特定工作模式中对输入报文进行填充操作，来达到报文的加密要求（避免输入报文长度不一）\n填充方式有补0位（zero），ANSI X9.23（补0位，并且在填充内容最后一个字节为填充内容的长度），ISO 10126（填充随机数，并且在填充内容最后一个字节为填充内容的长度），PKCS 7（需要填充多长数据，就填充多少，需要填充n个，就填充n，取决于需要填充多长，PKSC 5是PKCS 7的子集，PKCS 5只支持8个字节的补齐）\n常见的工作模式：电子密码本（ECB模式），密码分块链接（CBC模式），密文反馈（CFB模式），输出反馈（OFB模式），计数器（CTR模式），伽罗瓦计数（GCM模式）\n电子密码本：直接将明文进行分块加密，加密完成后就成为输出的密文分组，一个明文分组对于着一组密文分组，解密时也是直接将密文块解成对于的明文\n密码分块链接：明文分组后，将一个明文块与上一个密文块进行异或计算，在进行对其进行加密处理，因为其每个密文块都依赖于前面的明文块，并且将在第一个块使用初始化向量作为上一个密文结果进行处理\n注意：因为CBC模式加密是依赖于上一个密文块的，因此加密过程是无法并行处理的，并且明文的小小的改动，都会导致全部密文块的改变，但是在解密过程在，是可以通过两个相邻的密文块得到一个明文块的，所以是可以并行处理解密的，而且因为密文只依赖于对应的明文块和下一个明文块，所以密文某个组的密文发生改变，不会影响其他明文组的，简单的来说就是加密依赖于上一个，解密不依赖，只依赖其对于的明文块，因为加密过程是通过上一个密文块处理得到的，因此也依赖于上一个密文块，其他都是不会受影响的\n密文反馈：使用前一次密文结果继续加密操作，再和当前的明文进行异或计算，得到本次的密文，在第一次加密处理时，使用初始化向量IV进行加密处理，再通过于当前的明文进行异或计算，得到本次的密文，解密过程中将上一段的密文块进行加密，再通过与本次密文块进行异或计算，得到本次的明文块，第一次解密时通过初始化向量IV进行加密，再通过本次的密文块进行异或计算，得到第一次的明文块，解密过程是依赖于第一次的密文块和上一次的密文块的\n输出反馈：使用初始化向量IV进行加密处理，再通过明文进行异或，得到密文，操作和密文反馈是类似的，但是输出反馈进行下一次加密处理是依赖于对明文进行异或计算之前的密文，密文反馈是依赖于对明文进行异或计算后得到密文，解密过程也是一样\n计数器：在初始化向量IV的基础上设置一个计数器，通过加密器得到密文块，这个密文块与明文块进行异或计算，得到本次的密文结果，下一个加密时计数器自增，设置到那个初始化向量IV上，解密时也是通过初始化向量IV的基础上设置一个计数器进行加密，得到密文，和当前密文进行异或，得到当前的明文\n注意：明文分组之间以及密文分组之间是不依赖，每一次加密解密过程，都是独立的，一个明文块对于一个密文块\nCFB，OFB，CTR都是使用加密器来完成加密和解密工作的\n伽罗瓦计数：将附加信息，明文，以及初始化向量IV进行加密工作，得到一个密文和一个附加信息认证标签（保护附加信息），然后整合附加信息，初始化向量IV，密文，附加信息认证标签，得到一个完整的密文，该模式能解决无法对加密信息进行完整性检查的缺点\n使用一个自增的计数器，进行加密，得到的结果与明文进行异或得到密文\n附加信息通过GMAC后，与密文进行异或计算，得到附加信息认证标签\nGMAC通过伽罗瓦域的有效域乘法计算，来得到附加信息的标签值\n伽罗瓦计数会先对128位的0进行加密得到结果1，通过初始化向量IV进行判断，判断其是否等于96位（后面拼接31位0，再拼一个1，就是128位），如果等于就直接使用iv，如果不是，则进行GHASH函数处理，将上面得到结果1和IV，以及一个空集合，得到一个128位的数\nGHASH函数是在GF(2的128次方)的伽罗瓦域中的计算，GHASH函数会根据计数器来执行不同的计算方式，其是在有限域中的加法与乘法，其中是依赖于计数器上一次的结果的，输出结果是128位的\n这个GCM模式，如果学过http协议的，应该感觉很熟悉，因为GCM模式作为TLS可选算法之一，全程叫AES128-GCM，使用AES256对称算法，128位长度，分组就采用了这个GCM模式\n而源IP，源端口，目的ip等等信息作为附加信息（也就是头部）进行加密。得到认证标签，不但可以进行信息的加密，还可以确保完整性\n非对称加密\n数字签名和消息完整性\n密钥的交换和数字信任链\n编码和解码\n","wordCount":"129","inLanguage":"en","datePublished":"2024-03-01T10:49:25+08:00","dateModified":"2024-03-01T10:49:25+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://99999.fun/posts/165/"},"publisher":{"@type":"Organization","name":"知政的个人博客","logo":{"@type":"ImageObject","url":"https://99999.fun/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://99999.fun/ accesskey=h title="知政的个人博客 (Alt + H)"><img src=https://99999.fun/favicon.ico alt aria-label=logo height=35>知政的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://99999.fun/ title=首页><span>首页</span></a></li><li><a href=https://99999.fun/categories/ title=分类><span>分类</span></a></li><li><a href=https://99999.fun/archives/ title=归档><span>归档</span></a></li><li><a href=https://99999.fun/tags/ title=标签><span>标签</span></a></li><li><a href=https://99999.fun/links/ title=链接><span>链接</span></a></li><li><a href=https://99999.fun/about/ title=关于><span>关于</span></a></li><li><a href=https://99999.fun/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://99999.fun/>Home</a>&nbsp;»&nbsp;<a href=https://99999.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">密码学的学习笔记</h1><div class=post-meta><span title='2024-03-01 10:49:25 +0800 CST'>2024-03-01</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://99999.fun//posts/%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密</p><p>信息安全（机密性，完整性，可用性，不可抵赖性）</p><hr><p>Hash函数</p><p>hash可以用于校验文件是否完整，数字签名的摘要信息等等</p><p>hash函数是将任意大小的输入映射成固定大小的哈希值的函数</p><p>hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）</p><p>常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等</p><p>md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）</p><p>简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算</p><p>sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）</p><p>md5和sha1的计算过程：</p><p>先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的</p><p>也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间</p><p>确保这个消息的长度=输入消息+64+填充 = 512的整倍数</p><p>md5会初始化4个32bit的值，sha1会初始化5个32bit的值</p><p>md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算</p><p>每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值</p><p>计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值</p><p>如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果</p><p>mod 模计算</p><p>sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式</p><p>注意：md5和sha1都不安全了</p><p>md5</p><p>cryptographically broken and unsuitable for further use</p><p>users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use</p><p>sha1</p><p>谷歌SHA1碰撞实验</p><p>结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数</p><hr><p>对称加密</p><p>AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14</p><p>计算过程：</p><p>AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）</p><p>128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵</p><p>加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵</p><p>先进行轮密钥加，每轮输入与轮密钥异或，得到的值，当解密的时候，只需要再异或该轮密钥即可得到输入，原理就是相同的两个数进行异或，结果为0，异或计算就是不带进位的二进制加法，1异或1，等于0，0异或1，等于1</p><p>然后字节替换（subbytes），经过轮密钥加每个字节通过十六进制进行表示，十六进制的第一个数为行，第二个数字为列，通过s盒找到对应十六进制进行替换，这个s盒是16x16的正方形矩阵，还有逆s盒，用来解密</p><p>s盒的16*16的十六进制是通过计算得到的，计算过程：</p><p>先进行16*16初始化，然后对每个元素计算其乘法逆元</p><p>以11为例（这个11是十六进制的），二进制为10001</p><p>10001的多项式为f(x) = x的5次方+1</p><p>意思为第1位和第五位为1</p><p>AES使用了不可约多项式m(x)=x8+x4+x3+x+1</p><p>行移位变换：就是将4*4的正方形矩阵的行都向左移动，例如第二行左移2位，第一行不变</p><p>列混淆变换：将4*4的正方形矩阵的取一列乘以C(X)矩阵，得到一个新的值，放回原来的位置</p><p>正方形矩阵的列和C(X)矩阵的行进行计算，就可以得到4*4的经过列混淆变换的新矩阵</p><p>列混淆变换计算过程：</p><p>假设取了A1，0B，BD，C1的一列数据</p><p>即（02*A1）,(03*0B)，(01*AF)，(01*C1)</p><p>通过十六进制转二进制，然后通过多项式表达式</p><p>02为10，为x</p><p>A1为10100001，为x的7次方+x的5次方+1</p><p>x乘以（x的7次方+x的5次方+1）= x的八次方+x的六次方+x</p><p>得到10100010，为A2</p><p>以此类推，得到四个二进制的值。然后这四个二进制进行异或相加，得到的值就是该列的新值</p><p>密钥扩展算法</p><p>将密钥编排成4个32位的初始密钥，最后一个32位的密钥通过G函数得到的结果，与第一个32位的密钥进行异或计算得到下一轮的第一个32位的密钥，下一轮的第一个32位的密钥和初始密钥的第二个的32位初始密钥进行异或，得到下一轮的第二个32位的密钥，一直计算到第11轮（轮密钥加需要进行10次，算上第0轮，也就是第11轮，也就是需要进行44次异或处理（4x11））</p><hr><p>分组密码（分块加密，块密码）</p><p>将明文分成多个等长的块，并且使用确定的加密算法和密钥对每一个分组的块分别加密或者解密</p><p>工作模式，分组密码的解决方案（避免密钥长度，输入文长度，重放，完整度等问题及隐患）</p><p>初始化向量（Initialization Vector）：随机初始化向量，生成一个随机的值，并且不会复用，确保其唯一性</p><p>填充方式（Padding）：在特定工作模式中对输入报文进行填充操作，来达到报文的加密要求（避免输入报文长度不一）</p><p>填充方式有补0位（zero），ANSI X9.23（补0位，并且在填充内容最后一个字节为填充内容的长度），ISO 10126（填充随机数，并且在填充内容最后一个字节为填充内容的长度），PKCS 7（需要填充多长数据，就填充多少，需要填充n个，就填充n，取决于需要填充多长，PKSC 5是PKCS 7的子集，PKCS 5只支持8个字节的补齐）</p><p>常见的工作模式：电子密码本（ECB模式），密码分块链接（CBC模式），密文反馈（CFB模式），输出反馈（OFB模式），计数器（CTR模式），伽罗瓦计数（GCM模式）</p><p>电子密码本：直接将明文进行分块加密，加密完成后就成为输出的密文分组，一个明文分组对于着一组密文分组，解密时也是直接将密文块解成对于的明文</p><p>密码分块链接：明文分组后，将一个明文块与上一个密文块进行异或计算，在进行对其进行加密处理，因为其每个密文块都依赖于前面的明文块，并且将在第一个块使用初始化向量作为上一个密文结果进行处理</p><p>注意：因为CBC模式加密是依赖于上一个密文块的，因此加密过程是无法并行处理的，并且明文的小小的改动，都会导致全部密文块的改变，但是在解密过程在，是可以通过两个相邻的密文块得到一个明文块的，所以是可以并行处理解密的，而且因为密文只依赖于对应的明文块和下一个明文块，所以密文某个组的密文发生改变，不会影响其他明文组的，简单的来说就是加密依赖于上一个，解密不依赖，只依赖其对于的明文块，因为加密过程是通过上一个密文块处理得到的，因此也依赖于上一个密文块，其他都是不会受影响的</p><p>密文反馈：使用前一次密文结果继续加密操作，再和当前的明文进行异或计算，得到本次的密文，在第一次加密处理时，使用初始化向量IV进行加密处理，再通过于当前的明文进行异或计算，得到本次的密文，解密过程中将上一段的密文块进行加密，再通过与本次密文块进行异或计算，得到本次的明文块，第一次解密时通过初始化向量IV进行加密，再通过本次的密文块进行异或计算，得到第一次的明文块，解密过程是依赖于第一次的密文块和上一次的密文块的</p><p>输出反馈：使用初始化向量IV进行加密处理，再通过明文进行异或，得到密文，操作和密文反馈是类似的，但是输出反馈进行下一次加密处理是依赖于对明文进行异或计算之前的密文，密文反馈是依赖于对明文进行异或计算后得到密文，解密过程也是一样</p><p>计数器：在初始化向量IV的基础上设置一个计数器，通过加密器得到密文块，这个密文块与明文块进行异或计算，得到本次的密文结果，下一个加密时计数器自增，设置到那个初始化向量IV上，解密时也是通过初始化向量IV的基础上设置一个计数器进行加密，得到密文，和当前密文进行异或，得到当前的明文</p><p>注意：明文分组之间以及密文分组之间是不依赖，每一次加密解密过程，都是独立的，一个明文块对于一个密文块</p><p>CFB，OFB，CTR都是使用加密器来完成加密和解密工作的</p><p>伽罗瓦计数：将附加信息，明文，以及初始化向量IV进行加密工作，得到一个密文和一个附加信息认证标签（保护附加信息），然后整合附加信息，初始化向量IV，密文，附加信息认证标签，得到一个完整的密文，该模式能解决无法对加密信息进行完整性检查的缺点</p><p>使用一个自增的计数器，进行加密，得到的结果与明文进行异或得到密文</p><p>附加信息通过GMAC后，与密文进行异或计算，得到附加信息认证标签</p><p>GMAC通过伽罗瓦域的有效域乘法计算，来得到附加信息的标签值</p><p>伽罗瓦计数会先对128位的0进行加密得到结果1，通过初始化向量IV进行判断，判断其是否等于96位（后面拼接31位0，再拼一个1，就是128位），如果等于就直接使用iv，如果不是，则进行GHASH函数处理，将上面得到结果1和IV，以及一个空集合，得到一个128位的数</p><p>GHASH函数是在GF(2的128次方)的伽罗瓦域中的计算，GHASH函数会根据计数器来执行不同的计算方式，其是在有限域中的加法与乘法，其中是依赖于计数器上一次的结果的，输出结果是128位的</p><p>这个GCM模式，如果学过http协议的，应该感觉很熟悉，因为GCM模式作为TLS可选算法之一，全程叫AES128-GCM，使用AES256对称算法，128位长度，分组就采用了这个GCM模式</p><p>而源IP，源端口，目的ip等等信息作为附加信息（也就是头部）进行加密。得到认证标签，不但可以进行信息的加密，还可以确保完整性</p><hr><p>非对称加密</p><p>数字签名和消息完整性</p><p>密钥的交换和数字信任链</p><p>编码和解码</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://99999.fun/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/>密码学</a></li></ul><nav class=paginav><a class=next href=https://99999.fun/posts/164/><span class=title>Next »</span><br><span>云计算学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://99999.fun/>知政的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>